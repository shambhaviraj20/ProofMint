type UserProfile = 
 record {
   createdAt: int;
   email: opt text;
   "principal": principal;
   publicIdeas: nat;
   reputation: nat;
   totalIdeas: nat;
   username: opt text;
 };
type SemanticReport = 
 record {
   risk: text;
   score: nat;
 };
type Result_4 = 
 variant {
   err: text;
   ok: Idea;
 };
type Result_3 = 
 variant {
   err: text;
   ok: ProofRecord;
 };
type Result_2 = 
 variant {
   err: text;
   ok: UserProfile;
 };
type Result_1 = 
 variant {
   err: text;
   ok: text;
 };
type Result = 
 variant {
   err: text;
   ok;
 };
type ProofRecord = 
 record {
   blockHeight: nat;
   canisterId: text;
   creator: principal;
   ideaId: text;
   isVerified: bool;
   network: text;
   proofHash: text;
   timestamp: int;
 };
type IdeaStatus = 
 variant {
   Private;
   Public;
   RevealLater;
 };
type IdeaInput = 
 record {
   category: text;
   description: text;
   ipfsHash: opt text;
   semantic: opt SemanticReport;
   status: IdeaStatus;
   tags: vec text;
   title: text;
 };
type Idea = 
 record {
   category: text;
   creator: principal;
   description: text;
   id: text;
   ipfsHash: opt text;
   isRevealed: bool;
   proofHash: text;
   revealTimestamp: opt int;
   semantic: opt SemanticReport;
   status: IdeaStatus;
   tags: vec text;
   timestamp: int;
   title: text;
   version: nat;
 };
service : {
  createCollaborativeIdea: (ideaId: text, collaborators: vec principal,
   requiredSignatures: nat) -> (Result);
  createUserProfile: (username: opt text, email: opt text) -> (Result_2);
  getIdea: (ideaId: text) -> (Result_4) query;
  getProofRecord: (ideaId: text) -> (Result_3) query;
  getPublicFeed: (limit: opt nat, category: opt text, tags: vec text) ->
   (vec Idea) query;
  getStats: () ->
   (record {
      publicIdeas: nat;
      totalIdeas: nat;
      totalUsers: nat;
    }) query;
  getUserIdeas: () -> (vec Idea);
  getUserProfile: () -> (Result_2);
  revealIdea: (ideaId: text) -> (Result);
  searchIdeas: (searchTerm: text, limit: opt nat) -> (vec Idea) query;
  signCollaborativeIdea: (ideaId: text) -> (Result);
  submitIdea: (input: IdeaInput) -> (Result_1);
  updateIdea: (ideaId: text, newDescription: text, newTags: vec text) ->
   (Result);
  verifyIdea: (ideaId: text, expectedHash: text) -> (bool) query;
}
